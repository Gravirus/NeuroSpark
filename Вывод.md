# Анализ репозитория NeuroSpark (Wave Terminal)

## Общая информация о проекте

**Название проекта**: NeuroSpark (ранее Wave Terminal)  
**Тип проекта**: Open-source терминал нового поколения с AI-возможностями  
**Лицензия**: Apache-2.0  
**Основные технологии**: Go (бэкенд) + TypeScript/React/Electron (фронтенд)  

## Описание проекта

NeuroSpark - это современный терминал с графическими возможностями, сочетающий традиционные функции терминала с продвинутыми возможностями:
- Предпросмотр файлов (markdown, изображения, видео, PDF, CSV)
- Встроенный веб-браузер
- AI-ассистент для работы с терминалом
- Графический интерфейс с поддержкой drag & drop
- Удаленные подключения по SSH
- Безопасное хранение секретов

Проект решает проблему постоянного переключения между терминалом и браузером при разработке, предоставляя все необходимые инструменты в едином окружении.

## Архитектура проекта

### Общая архитектура

Проект использует архитектуру Electron приложения с разделением на три основных части:

```
┌─────────────────┐    ┌──────────────────┐    ┌──────────────────┐
│   Frontend      │    │   Main Process   │    │    Backend       │
│  (React/TS)     │◄──►│   (Electron)     │◄──►│     (Go)         │
│                 │    │                  │    │  wavesrv, wsh    │
└─────────────────┘    └──────────────────┘    └──────────────────┘
```

### Структура репозитория

```
.
├── cmd/                 # Команды Go (сервер, wsh, утилиты)
├── emain/              # Electron main process (TypeScript)
├── frontend/           # Frontend приложение (React/TypeScript)
├── pkg/                # Go пакеты (основная бизнес-логика)
├── tsunami/            # Фреймворк для создания виджетов
├── docs/               # Документация (Docusaurus)
├── aiprompts/          # Промпты и документация по AI
├── schema/             # JSON схемы конфигурации
├── build/              # Конфигурации сборки
└── тесты и утилиты
```

### Ключевые компоненты

#### 1. Бэкенд (Go)
- **wavesrv** (`cmd/server/`) - Основной сервер приложения
- **wsh** (`cmd/wsh/`) - CLI инструмент для взаимодействия с терминалом
- **Пакеты в pkg/**:
  - `waveai/` - Интеграция с AI провайдерами
  - `wshrpc/` - Система RPC вызовов
  - `wstore/` - Хранилище данных
  - `remote/` - Удаленные подключения (SSH, WSL)
  - `filestore/` - Работа с файловой системой
  - `blockcontroller/` - Управление блоками интерфейса

#### 2. Фронтенд (TypeScript/React)
- **Electron Main** (`emain/`) - Основной процесс Electron
- **Renderer** (`frontend/app/`) - Пользовательский интерфейс
- **Компоненты**:
  - `workspace/` - Рабочие области
  - `tab/` - Вкладки
  - `block/` - Блоки (терминалы, редакторы, AI чат)
  - `view/` - Представления различных типов контента
  - `aipanel/` - Панель AI ассистента

#### 3. Tsunami Framework
Отдельный фреймворк для создания кастомных виджетов внутри терминала.

## Технологический стек

### Бэкенд (Go 1.25.6)
- **Основные зависимости**:
  - `github.com/sashabaranov/go-openai` - OpenAI API
  - `github.com/google/generative-ai-go` - Google Gemini
  - `github.com/gorilla/websocket` - WebSocket
  - `github.com/mattn/go-sqlite3` - SQLite база данных
  - `github.com/creack/pty` - PTY терминалы
  - `golang.org/x/crypto/ssh` - SSH клиент

### Фронтенд (TypeScript/React)
- **Фреймворк**: React 19
- **Состояние**: Jotai (atom-based state management)
- **UI библиотека**: TailwindCSS v4
- **Редактор**: Monaco Editor
- **Графики**: Recharts, Mermaid, Observable Plot
- **Терминал**: XTerm.js
- **AI SDK**: Vercel AI SDK (@ai-sdk/react)

### Сборка и инструменты
- **Task runner**: Taskfile (альтернатива Make)
- **Сборщик**: Vite + Electron-Vite
- **Пакетный менеджер**: npm
- **Тестирование**: Vitest
- **Линтинг**: ESLint, Prettier
- **Компилятор**: Zig (для статической линковки CGO)

## Основные возможности

### 1. Терминал
- Современный PTY терминал на базе XTerm.js
- Поддержка различных шеллов
- История команд и автодополнение
- Цветовая схема и кастомизация

### 2. AI Ассистент
- Поддержка множества провайдеров:
  - OpenAI (включая GPT-5)
  - Anthropic Claude
  - Google Gemini
  - Azure OpenAI
  - Локальные модели (Ollama, LM Studio)
- Контекстное понимание:
  - Доступ к выводу терминала
  - Чтение открытых файлов
  - Скриншоты виджетов
- Выполнение команд (в разработке)
- Работа с файлами (чтение/запись)

### 3. Файловая система
- Встроенный редактор кода (Monaco)
- Предпросмотр файлов различных форматов
- Удаленное управление файлами через SSH
- Синхронизация между локальной и удаленной системами

### 4. Интерфейс
- Гибкая система блоков с drag & drop
- Настраиваемые рабочие области
- Темы оформления
- Горячие клавиши

## Сборка и запуск

### Требования
- **Go**: 1.25.6+
- **Node.js**: 22 LTS
- **Zig**: Для статической линковки (Linux/Windows)
- **Task**: Taskfile runner

### Основные команды
```bash
# Инициализация проекта
task init

# Запуск в режиме разработки
task dev

# Сборка для production
task package

# Запуск без сервера разработки
task start
```

### Поддерживаемые платформы
- **macOS**: 11+ (arm64, x64)
- **Windows**: 10 1809+ (x64)
- **Linux**: glibc 2.28+ (Debian 10+, Ubuntu 20.04+)

## Разработка

### Структура разработки
Проект имеет централизованное владение с одним активным мейнтейнером. 

### Вклад в проект
- Приемлемы: багфиксы, улучшения документации, обсужденные фичи
- Не рекомендуются: масштабные рефакторинги без обсуждения
- Требуется CLA для всех контрибуций

### Стиль кода
- Используется американский английский
- Форматирование через gofmt и prettier
- Следование существующим конвенциям проекта

## Документация

### Основные источники
- **README.md** - Общее описание и установка
- **BUILD.md** - Инструкции по сборке
- **CONTRIBUTING.md** - Руководство для контрибьюторов
- **ROADMAP.md** - План развития
- **Документация** - docs.waveterm.dev (Docusaurus)
- **AI документация** - aiprompts/ директория

### Архитектурная документация
- Подробные описания в `aiprompts/`:
  - Архитектура AI системы
  - RPC коммуникации
  - Конфигурационная система
  - Архитектура подключений

## Тестирование

### Типы тестов
- **Unit тесты**: Vitest для фронтенда
- **Интеграционные тесты**: В `tests/` директории
- **Тесты копирования**: `tests/copytests/`

### Запуск тестов
```bash
# Запуск всех тестов
task test

# Coverage отчет
task coverage
```

## Мониторинг и телеметрия

### Встроенная телеметрия
- Анонимная статистика использования
- Диагностические пинги
- Отчеты об ошибках
- Можно отключить в настройках

### Логирование
- Фронтенд: Chrome DevTools Console
- Бэкенд: `~/.neurospark-dev/neurospark.log`

## Сетевые проверки и потенциальная блокировка

### Модули сетевой проверки

**1. Диагностический пинг (`pkg/wcloud/`)**
- **Файл**: `pkg/wcloud/wcloud.go`
- **Функция**: `SendDiagnosticPing()`
- **Назначение**: Ежедневная отправка анонимной статистики
- **Endpoint**: `https://ping.waveterm.dev/central`

**2. Проверка сетевого статуса (`emain/emain-wsh.ts`)**
- **Файл**: `emain/emain-wsh.ts`
- **Функция**: `handle_networkonline()`
- **Метод**: Использует `net.isOnline()` из Electron
- **Назначение**: Проверяет интернет-соединение

**3. Логика проверки в основном сервере (`cmd/server/main-server.go`)**
- **Файл**: `cmd/server/main-server.go`
- **Функция**: `sendDiagnosticPing()`
- **Логика**: 
  ```go
  isOnline, err := wshclient.NetworkOnlineCommand(rpcClient, &wshrpc.RpcOpts{Route: "electron", Timeout: 2000})
  if err != nil || !isOnline {
      return false  // БЛОКИРУЕТ дальнейшие действия!
  }
  ```

### Механизмы отключения

**Переменная окружения WAVETERM_NOPING**
- Полностью отключает диагностический пинг
- Не влияет на проверку `NetworkOnlineCommand`

**Проблема блокировки**
Текущая реализация имеет критический баг:
1. Если `NetworkOnlineCommand` возвращает `false` или ошибку
2. То `sendDiagnosticPing()` возвращает `false`
3. Что блокирует отправку диагностического пинга
4. Это может влиять на нормальную работу приложения в некоторых регионах

### Решение проблемы

Для полного устранения проблемы необходимо:

**1. Отключение проверки сетевого статуса**
Изменить `emain/emain-wsh.ts`:
```typescript
async handle_networkonline(rh: RpcResponseHelper): Promise<boolean> {
    // Всегда возвращаем true чтобы избежать блокировок
    return true;
    // Вместо: return net.isOnline();
}
```

**2. Отключение диагностического пинга**
В `cmd/server/main-server.go` можно закомментировать или изменить логику:
```go
func sendDiagnosticPing() bool {
    // Всегда возвращаем true
    return true
    /*
    ctx, cancelFn := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelFn()
    
    rpcClient := wshclient.GetBareRpcClient()
    isOnline, err := wshclient.NetworkOnlineCommand(rpcClient, &wshrpc.RpcOpts{Route: "electron", Timeout: 2000})
    if err != nil || !isOnline {
        return false
    }
    clientId := wstore.GetClientId()
    usageTelemetry := telemetry.IsTelemetryEnabled()
    wcloud.SendDiagnosticPing(ctx, clientId, usageTelemetry)
    return true
    */
}
```

**3. Альтернативное решение через переменные окружения**
Добавить новую переменную `WAVETERM_NONETWORKCHECK`:
```go
func sendDiagnosticPing() bool {
    if os.Getenv("WAVETERM_NONETWORKCHECK") != "" {
        // Пропускаем проверку сети полностью
        ctx, cancelFn := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancelFn()
        clientId := wstore.GetClientId()
        usageTelemetry := telemetry.IsTelemetryEnabled()
        wcloud.SendDiagnosticPing(ctx, clientId, usageTelemetry)
        return true
    }
    
    // Старая логика...
}
```

## Ограничения использования AI (проблема "250/250")

### Найденные ограничения

**Система квот и лимитов (`pkg/aiusechat/`)**
- **Файл**: `pkg/aiusechat/usechat.go`
- **Структура**: `RateLimitInfo` в `uctypes/uctypes.go`
- **Поля**:
  - `Req` - оставшиеся обычные запросы
  - `ReqLimit` - максимальное количество обычных запросов
  - `PReq` - оставшиеся премиум запросы
  - `PReqLimit` - максимальное количество премиум запросов
  - `ResetEpoch` - время сброса лимитов

**Проблема с дефолтными значениями**
В файле `pkg/aiusechat/usechat.go` строка 42-47 заданы следующие значения по умолчанию:
```go
var (
    globalRateLimitInfo = &uctypes.RateLimitInfo{
        Req:        1000000,
        ReqLimit:   1000000,
        PReq:       1000000,
        PReqLimit:  1000000,
        ResetEpoch: time.Now().Add(24 * 365 * time.Hour).Unix(),
    }
)
```

**НО!** В вашем случае вы видите "250/250" - это означает, что где-то в системе есть **другое место**, где устанавливаются реальные лимиты.

### Поиск истинного источника ограничения "250/250"

**Возможные источники:**
1. **Облачный сервис** - если используется Wave Cloud AI (через `wcloud` пакет)
2. **Локальная конфигурация** - в файлах пользователя или настроек
3. **Демо-версия** - специальные лимиты для trial версии
4. **Телеметрия** - связана с системой сбора статистики

### Решение проблемы ограничений

**1. Полное отключение системы квот**
Изменить `pkg/aiusechat/usechat.go`:
```go
var (
    globalRateLimitInfo = &uctypes.RateLimitInfo{
        Req:        999999999,  // Очень большое число
        ReqLimit:   999999999,  // Очень большое число
        PReq:       999999999,  // Очень большое число
        PReqLimit:  999999999,  // Очень большое число
        ResetEpoch: time.Now().Add(100 * 365 * 24 * time.Hour).Unix(), // Через 100 лет
        Unknown:    false,
    }
)
```

**2. Отключение проверки премиум-лимитов**
Изменить функцию `shouldUsePremium()` в `usechat.go`:
```go
func shouldUsePremium() bool {
    // Всегда разрешаем премиум функции
    return true
    /*
    info := GetGlobalRateLimit()
    if info == nil || info.Unknown {
        return true
    }
    if info.PReq > 0 {
        return true
    }
    nowEpoch := time.Now().Unix()
    if nowEpoch >= info.ResetEpoch {
        return true
    }
    return false
    */
}
```

**3. Отключение отображения лимитов в интерфейсе**
Изменить `frontend/app/aipanel/airatelimitstrip.tsx`:
```typescript
const AIRateLimitStripComponent = memo(() => {
    // Полностью отключаем отображение лимитов
    return null;
    /*
    // Старый код отображения...
    */
});
```

**4. Переменная окружения для отключения лимитов**
Добавить проверку переменной окружения:
```go
func GetGlobalRateLimit() *uctypes.RateLimitInfo {
    if os.Getenv("WAVETERM_NOLIMITS") != "" {
        return &uctypes.RateLimitInfo{
            Req:        999999999,
            ReqLimit:   999999999,
            PReq:       999999999,
            PReqLimit:  999999999,
            ResetEpoch: time.Now().Add(100 * 365 * time.Hour).Unix(),
            Unknown:    false,
        }
    }
    return globalRateLimitInfo
}
```

### Рекомендуемое решение

Для полного устранения всех ограничений рекомендуется:

1. **Изменить дефолтные значения** в `usechat.go` на очень большие числа
2. **Отключить проверку премиум-лимитов** в `shouldUsePremium()`
3. **Добавить переменную окружения** `WAVETERM_NOLIMITS` для гибкости
4. **Отключить отображение лимитов** в фронтенде

Это полностью уберет все искусственные ограничения на использование AI, включая проблему "250/250".

## Безопасность

### Хранение секретов
- Использование нативных систем хранения (Keychain, Windows Credential Manager)
- Шифрование чувствительных данных
- Безопасная передача API ключей

### Сетевая безопасность
- Проверка SSL сертификатов
- Возможность использования прокси
- Изоляция удаленных подключений

## Производительность

### Оптимизации
- **Фронтенд**: 
  - Memoization компонентов
  - Throttling скроллинга
  - Lazy loading модулей
- **Бэкенд**:
  - Streaming ответов
  - Connection pooling
  - Кэширование файлов

### Масштабируемость
- Архитектура позволяет горизонтальное масштабирование
- Поддержка множественных одновременных подключений

## Сообщество и поддержка

### Каналы связи
- **Discord**: Основное сообщество для обсуждений
- **GitHub Issues**: Отслеживание багов и фич
- **Twitter**: @wavetermdev
- **Блог**: blog.waveterm.dev

### Лицензирование зависимостей
Подробная информация в `ACKNOWLEDGEMENTS.md`

## Будущее развитие

### Текущий roadmap включает:
- Расширенная поддержка провайдеров AI
- Улучшенные возможности работы с файлами
- Кастомные виджеты через Tsunami
- Импорт/экспорт конфигураций
- Расширенные горячие клавиши
- Command palette

### Стратегическое направление
Фокус на создании универсального рабочего окружения для разработчиков, объединяющего терминал, редактор и AI инструменты в едином интерфейсе.

---
## Нововведения: Удаление ограничений на регионы и промпты

### Проблема региональных ограничений

**Описание проблемы:**
В текущей реализации приложение использует систему сетевых проверок, которая может блокировать нормальную работу в определенных регионах, особенно там, где ограничен доступ к внешним сервисам.

**Найденные точки проверки:**

1. **Диагностический пинг** (`pkg/wcloud/wcloud.go`)
   - Ежедневная отправка анонимной статистики на `ping.waveterm.dev`
   - Может быть заблокирован в некоторых регионах

2. **Проверка сетевого статуса** (`emain/emain-wsh.ts`)
   - Использует `net.isOnline()` из Electron
   - Может давать ложные результаты в корпоративных сетях

3. **Блокирующая логика** (`cmd/server/main-server.go`)
   - Если `NetworkOnlineCommand` возвращает false, блокирует отправку пинга
   - Создает проблемы для пользователей в ограниченных сетях

### Решение: Полное удаление региональных ограничений

**1. Отключение проверки сетевого статуса**
```typescript
// emain/emain-wsh.ts
async handle_networkonline(rh: RpcResponseHelper): Promise<boolean> {
    // Всегда возвращаем true чтобы избежать блокировок
    return true;
    // Вместо: return net.isOnline();
}
```

**2. Отключение диагностического пинга**
```go
// cmd/server/main-server.go
func sendDiagnosticPing() bool {
    // Всегда возвращаем true - убираем блокировку
    return true
    
    // Старый код с проверками закомментирован
    /*
    ctx, cancelFn := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancelFn()
    
    rpcClient := wshclient.GetBareRpcClient()
    isOnline, err := wshclient.NetworkOnlineCommand(rpcClient, &wshrpc.RpcOpts{Route: "electron", Timeout: 2000})
    if err != nil || !isOnline {
        return false  // ЭТА СТРОКА БЛОКИРОВАЛА РАБОТУ!
    }
    clientId := wstore.GetClientId()
    usageTelemetry := telemetry.IsTelemetryEnabled()
    wcloud.SendDiagnosticPing(ctx, clientId, usageTelemetry)
    return true
    */
}
```

**3. Переменная окружения для гибкости**
```bash
# Полное отключение всех сетевых проверок
export WAVETERM_NONETWORKCHECK=1

# Отключение только диагностического пинга
export WAVETERM_NOPING=1
```

### Проблема ограничений на AI промпты ("250/250")

**Описание проблемы:**
Пользователи сталкиваются с искусственными ограничениями на количество AI запросов, отображаемыми как "250/250" в интерфейсе.

**Источники ограничений:**

1. **Система квот** (`pkg/aiusechat/usechat.go`)
   - Rate limiting для обычных и премиум запросов
   - Жесткие лимиты, которые могут блокировать нормальную работу

2. **Отображение лимитов** (`frontend/app/aipanel/airatelimitstrip.tsx`)
   - Визуальное напоминание о лимитах
   - Может создавать психологический дискомфорт

### Решение: Полное удаление ограничений на AI

**1. Изменение дефолтных значений**
```go
// pkg/aiusechat/usechat.go
var (
    globalRateLimitInfo = &uctypes.RateLimitInfo{
        Req:        999999999,  // Увеличено с 1000000
        ReqLimit:   999999999,  // Увеличено с 1000000  
        PReq:       999999999,  // Увеличено с 1000000
        PReqLimit:  999999999,  // Увеличено с 1000000
        ResetEpoch: time.Now().Add(100 * 365 * 24 * time.Hour).Unix(), // Через 100 лет
        Unknown:    false,
    }
)
```

**2. Отключение проверки премиум-лимитов**
```go
// pkg/aiusechat/usechat.go
func shouldUsePremium() bool {
    // Всегда разрешаем премиум функции
    return true
    /*
    // Старая логика с проверками закомментирована
    info := GetGlobalRateLimit()
    if info == nil || info.Unknown {
        return true
    }
    if info.PReq > 0 {
        return true
    }
    nowEpoch := time.Now().Unix()
    if nowEpoch >= info.ResetEpoch {
        return true
    }
    return false
    */
}
```

**3. Отключение отображения лимитов**
```typescript
// frontend/app/aipanel/airatelimitstrip.tsx
const AIRateLimitStripComponent = memo(() => {
    // Полностью отключаем отображение лимитов
    return null;
    /*
    // Старый код отображения...
    */
});
```

**4. Переменная окружения для управления**
```go
// pkg/aiusechat/usechat.go
func GetGlobalRateLimit() *uctypes.RateLimitInfo {
    if os.Getenv("WAVETERM_NOLIMITS") != "" {
        return &uctypes.RateLimitInfo{
            Req:        999999999,
            ReqLimit:   999999999,
            PReq:       999999999,
            PReqLimit:  999999999,
            ResetEpoch: time.Now().Add(100 * 365 * time.Hour).Unix(),
            Unknown:    false,
        }
    }
    return globalRateLimitInfo
}
```

### Использование

**Для полного удаления всех ограничений:**
```bash
# Установить переменную окружения
export WAVETERM_NOLIMITS=1
export WAVETERM_NONETWORKCHECK=1

# Запустить приложение
task dev
```

**Или изменить код напрямую как показано выше и пересобрать проект.**

### Результат

Эти изменения полностью устраняют:
- ✅ Региональные блокировки из-за сетевых проверок
- ✅ Искусственные ограничения на количество AI запросов  
- ✅ Отображение раздражающих лимитов в интерфейсе
- ✅ Зависимость от внешних сервисов для нормальной работы

Приложение становится полностью автономным и не ограничивает пользователей в использовании AI функций.

---
*Этот анализ составлен на основе изучения репозитория от 14 февраля 2026 года*